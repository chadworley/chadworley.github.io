```{r data generation, echo = FALSE, results = "hide"}
funs = list(c("$f(x)=\\lvert x \\rvert$","absolute value",function(x){abs(x)}),
            c("$f(x)=x^2$","quadratic",function(x){x^2}),
            c("$f(x)=x^3$","cubic",function(x){x^3}),
            c("$f(x)=\\frac{1}{x}$","reciprocal",function(x){1/x}),
            c("$f(x)=\\sqrt{x}$","square root",function(x){x^(1/2)}),
            c("$f(x)=\\sqrt[3]{x}$","cube root",function(x){abs(x)^(1/3)*sign(x)}),
            c("$f(x)=2^{x}$","exponential",function(x){2^x}),
            c("$f(x)=\\log_{2}(x)$","logarithmic",function(x){log(x)/log(2)})
            )

fun2 = list(c("\\lvert x \\rvert","absolute value",function(x){abs(x)}),
            c("(x)^2","quadratic",function(x){x^2}),
            c("(x)^3","cubic",function(x){x^3}),
            c("\\frac{1}{x}","reciprocal",function(x){1/x}),
            c("\\sqrt{x}","square root",function(x){x^(1/2)}),
            c("\\sqrt[3]{x}","cube root",function(x){abs(x)^(1/3)*sign(x)}),
            c("2^{x}","exponential",function(x){2^x}),
            c("\\log_{2}(x)","logarithmic",function(x){log(x)/log(2)})
            )

n = length(funs)
w = sample(1:n,1)
fe = funs[[w]][[1]]
fn = funs[[w]][[2]]
ff = funs[[w]][[3]]

hk = sample(1:6,2)*sample(c(-1,1),2,T)
h = hk[1]
k = hk[2]

names = character()
for(i in 1:length(funs)){
    names = c(names,funs[[i]][[2]])
}

al1 = paste0("* ",names,collapse="\n")
ca1 = names[w]
sol1 = paste0(1*(ca1==names),collapse="")

trans = character()
for(i in c(-1,1)){
    for(j in c(-1,1)){
        tran = paste0("y = f(x+",abs(h)*i,")+",abs(k)*j,collapse="")
        tran = gsub("+-","-",tran,fixed=T)
        trans = c(trans,tran)
        tran = paste0("y = f(x+",abs(k)*i,")+",abs(h)*j,collapse="")
        tran = gsub("+-","-",tran,fixed=T)
        trans = c(trans,tran)
    }
}
trans = sort(trans)
ctran = paste0("y = f(x+",-h,")+",k,collapse="")
ctran = gsub("+-","-",ctran,fixed=T)
al2 = paste0("* ",trans,collapse="\n")
sol2 = paste0(1*(ctran==trans),collapse="")


fullans = fun2[[w]][[1]]
arg = paste0("x+",-h,collapse="")
arg = gsub("+-","-",arg,fixed=T)
fullans = gsub("x",arg,fullans,fixed=T)
fullans = paste0(fullans,"+",k,collapse="")
fullans = gsub("+-","-",fullans,fixed=T)

lr = c("left","right")[round(sign(h)/2+1.5)]
du = c("down","up")[round(sign(k)/2+1.5)]

```

Question
========

Below are some common parent functions.

```{r,echo=F,warning=F}
library(kableExtra)

names = character()
lats = character()
for(i in 1:length(funs)){
    lats = c(lats,funs[[i]][[1]])
    names = c(names,funs[[i]][[2]])
}
df = data.frame(names,lats)
colnames(df) = c("names","expressions")
kable(df) %>%
    kable_styling("bordered",full_width = F)
```

One of those parent functions has been translated (shifted) to produce the graph below:

```{r,echo=F,fig.dim=c(5,5),warning=F}
par(mar=c(0,0,0,0),oma=c(0,0,0,0),pty="s")
plot(0,0,"n",xlim=c(-10,10),ylim=c(-10,10),axes=F,ann=F)

for(i in -10:10){
    lines(c(-10,10),c(i,i),col="grey",lwd=0.5)
    lines(c(i,i),c(-10,10),col="grey",lwd=0.5)
}
for(i in seq(-10,10,5)){
    lines(c(-10,10),c(i,i),col="darkgrey",lwd=0.8)
    lines(c(i,i),c(-10,10),col="darkgrey",lwd=0.8)
}
abline(h=0,lwd=2)
abline(v=0,lwd=2)

x = seq(-10,10,0.00001)
y = ff(x-h)+k
x2 = x[!is.na(y)]
y2 = y[!is.na(y)]
x = x2[abs(y2)<=10]
y = y2[abs(y2)<=10]
breaks = c(0,which(abs(diff(y))>10),length(x))
for(j in 1:(length(breaks)-1)){
    suppressWarnings(lines(x[(breaks[j]+1):(breaks[j+1]-1)],y[(breaks[j]+1):(breaks[j+1]-1)],type="l",lwd=4,col="blue"))
}

xp = -10:10
yp = ff(xp-h)+k
xp2 = xp[!is.na(yp)]
yp2 = yp[!is.na(yp)]
xp = xp2[abs(yp2)<=10]
yp = yp2[abs(yp2)<=10]
if(length(yp)>0){
    for(i in 1:length(xp)){
        if(yp[i]%%1==0){points(xp[i],yp[i],pch=19,cex=0.8,col="blue")}
    }
}


```
\

* Which parent function was used?

##ANSWER1##

* What translation was used?

##ANSWER2##


Answerlist
--------

`r al1`
`r al2`



Solution
========

The equation used to produce the plot was:
$$y~=~`r fullans`$$

In other words, the parent function was the `r names[w]` function: `r fe`. The parent function was shifted `r abs(h)` units `r lr` and `r abs(k)` units `r du`, so the function-transformation equation was $`r ctran`$.

Here is a graph of the parent (in grey) and child (in blue).

```{r,echo=F,fig.dim=c(5,5),warning=F}
par(mar=c(0,0,0,0),oma=c(0,0,0,0),pty="s")
plot(0,0,"n",xlim=c(-10,10),ylim=c(-10,10),axes=F,ann=F)

for(i in -10:10){
    lines(c(-10,10),c(i,i),col="grey",lwd=0.5)
    lines(c(i,i),c(-10,10),col="grey",lwd=0.5)
}
for(i in seq(-10,10,5)){
    lines(c(-10,10),c(i,i),col="darkgrey",lwd=0.8)
    lines(c(i,i),c(-10,10),col="darkgrey",lwd=0.8)
}
abline(h=0,lwd=2)
abline(v=0,lwd=2)

x = seq(-10,10,0.0001)
y = ff(x)
x2 = x[!is.na(y)]
y2 = y[!is.na(y)]
x = x2[abs(y2)<=10]
y = y2[abs(y2)<=10]
breaks = c(0,which(abs(diff(y))>10),length(x))
for(j in 1:(length(breaks)-1)){
    suppressWarnings(lines(x[(breaks[j]+1):(breaks[j+1]-1)],y[(breaks[j]+1):(breaks[j+1]-1)],type="l",lwd=4,col="grey"))
}

xp = -10:10
yp = ff(xp)
xp2 = xp[!is.na(yp)]
yp2 = yp[!is.na(yp)]
xp = xp2[abs(yp2)<=10]
yp = yp2[abs(yp2)<=10]
if(length(yp)>0){
    for(i in 1:length(xp)){
        if(yp[i]%%1==0){points(xp[i],yp[i],pch=19,cex=0.8,col="grey")}
    }
}

x = seq(-10,10,0.0001)
y = ff(x-h)+k
x2 = x[!is.na(y)]
y2 = y[!is.na(y)]
x = x2[abs(y2)<=10]
y = y2[abs(y2)<=10]
breaks = c(0,which(abs(diff(y))>10),length(x))
for(j in 1:(length(breaks)-1)){
    suppressWarnings(lines(x[(breaks[j]+1):(breaks[j+1]-1)],y[(breaks[j]+1):(breaks[j+1]-1)],type="l",lwd=4,col="blue"))
}


xp = -10:10
yp = ff(xp-h)+k
xp2 = xp[!is.na(yp)]
yp2 = yp[!is.na(yp)]
xp = xp2[abs(yp2)<=10]
yp = yp2[abs(yp2)<=10]
if(length(yp)>0){
    for(i in 1:length(xp)){
        if(yp[i]%%1==0){points(xp[i],yp[i],pch=19,cex=0.8,col="blue")}
    }
}


```
\

Meta-information
============
extype: cloze
exclozetype: schoice|schoice
exsolution: `r sol1`|`r sol2`
exname: id_parent_and_shift